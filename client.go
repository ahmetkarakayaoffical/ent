// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/open-uem/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/open-uem/ent/agent"
	"github.com/open-uem/ent/antivirus"
	"github.com/open-uem/ent/app"
	"github.com/open-uem/ent/certificate"
	"github.com/open-uem/ent/computer"
	"github.com/open-uem/ent/deployment"
	"github.com/open-uem/ent/logicaldisk"
	"github.com/open-uem/ent/metadata"
	"github.com/open-uem/ent/monitor"
	"github.com/open-uem/ent/networkadapter"
	"github.com/open-uem/ent/operatingsystem"
	"github.com/open-uem/ent/orgmetadata"
	"github.com/open-uem/ent/printer"
	"github.com/open-uem/ent/profile"
	"github.com/open-uem/ent/release"
	"github.com/open-uem/ent/revocation"
	"github.com/open-uem/ent/server"
	"github.com/open-uem/ent/sessions"
	"github.com/open-uem/ent/settings"
	"github.com/open-uem/ent/share"
	"github.com/open-uem/ent/systemupdate"
	"github.com/open-uem/ent/tag"
	"github.com/open-uem/ent/task"
	"github.com/open-uem/ent/update"
	"github.com/open-uem/ent/user"
	"github.com/open-uem/ent/wingetconfigexclusion"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Agent is the client for interacting with the Agent builders.
	Agent *AgentClient
	// Antivirus is the client for interacting with the Antivirus builders.
	Antivirus *AntivirusClient
	// App is the client for interacting with the App builders.
	App *AppClient
	// Certificate is the client for interacting with the Certificate builders.
	Certificate *CertificateClient
	// Computer is the client for interacting with the Computer builders.
	Computer *ComputerClient
	// Deployment is the client for interacting with the Deployment builders.
	Deployment *DeploymentClient
	// LogicalDisk is the client for interacting with the LogicalDisk builders.
	LogicalDisk *LogicalDiskClient
	// Metadata is the client for interacting with the Metadata builders.
	Metadata *MetadataClient
	// Monitor is the client for interacting with the Monitor builders.
	Monitor *MonitorClient
	// NetworkAdapter is the client for interacting with the NetworkAdapter builders.
	NetworkAdapter *NetworkAdapterClient
	// OperatingSystem is the client for interacting with the OperatingSystem builders.
	OperatingSystem *OperatingSystemClient
	// OrgMetadata is the client for interacting with the OrgMetadata builders.
	OrgMetadata *OrgMetadataClient
	// Printer is the client for interacting with the Printer builders.
	Printer *PrinterClient
	// Profile is the client for interacting with the Profile builders.
	Profile *ProfileClient
	// Release is the client for interacting with the Release builders.
	Release *ReleaseClient
	// Revocation is the client for interacting with the Revocation builders.
	Revocation *RevocationClient
	// Server is the client for interacting with the Server builders.
	Server *ServerClient
	// Sessions is the client for interacting with the Sessions builders.
	Sessions *SessionsClient
	// Settings is the client for interacting with the Settings builders.
	Settings *SettingsClient
	// Share is the client for interacting with the Share builders.
	Share *ShareClient
	// SystemUpdate is the client for interacting with the SystemUpdate builders.
	SystemUpdate *SystemUpdateClient
	// Tag is the client for interacting with the Tag builders.
	Tag *TagClient
	// Task is the client for interacting with the Task builders.
	Task *TaskClient
	// Update is the client for interacting with the Update builders.
	Update *UpdateClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// WingetConfigExclusion is the client for interacting with the WingetConfigExclusion builders.
	WingetConfigExclusion *WingetConfigExclusionClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Agent = NewAgentClient(c.config)
	c.Antivirus = NewAntivirusClient(c.config)
	c.App = NewAppClient(c.config)
	c.Certificate = NewCertificateClient(c.config)
	c.Computer = NewComputerClient(c.config)
	c.Deployment = NewDeploymentClient(c.config)
	c.LogicalDisk = NewLogicalDiskClient(c.config)
	c.Metadata = NewMetadataClient(c.config)
	c.Monitor = NewMonitorClient(c.config)
	c.NetworkAdapter = NewNetworkAdapterClient(c.config)
	c.OperatingSystem = NewOperatingSystemClient(c.config)
	c.OrgMetadata = NewOrgMetadataClient(c.config)
	c.Printer = NewPrinterClient(c.config)
	c.Profile = NewProfileClient(c.config)
	c.Release = NewReleaseClient(c.config)
	c.Revocation = NewRevocationClient(c.config)
	c.Server = NewServerClient(c.config)
	c.Sessions = NewSessionsClient(c.config)
	c.Settings = NewSettingsClient(c.config)
	c.Share = NewShareClient(c.config)
	c.SystemUpdate = NewSystemUpdateClient(c.config)
	c.Tag = NewTagClient(c.config)
	c.Task = NewTaskClient(c.config)
	c.Update = NewUpdateClient(c.config)
	c.User = NewUserClient(c.config)
	c.WingetConfigExclusion = NewWingetConfigExclusionClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                   ctx,
		config:                cfg,
		Agent:                 NewAgentClient(cfg),
		Antivirus:             NewAntivirusClient(cfg),
		App:                   NewAppClient(cfg),
		Certificate:           NewCertificateClient(cfg),
		Computer:              NewComputerClient(cfg),
		Deployment:            NewDeploymentClient(cfg),
		LogicalDisk:           NewLogicalDiskClient(cfg),
		Metadata:              NewMetadataClient(cfg),
		Monitor:               NewMonitorClient(cfg),
		NetworkAdapter:        NewNetworkAdapterClient(cfg),
		OperatingSystem:       NewOperatingSystemClient(cfg),
		OrgMetadata:           NewOrgMetadataClient(cfg),
		Printer:               NewPrinterClient(cfg),
		Profile:               NewProfileClient(cfg),
		Release:               NewReleaseClient(cfg),
		Revocation:            NewRevocationClient(cfg),
		Server:                NewServerClient(cfg),
		Sessions:              NewSessionsClient(cfg),
		Settings:              NewSettingsClient(cfg),
		Share:                 NewShareClient(cfg),
		SystemUpdate:          NewSystemUpdateClient(cfg),
		Tag:                   NewTagClient(cfg),
		Task:                  NewTaskClient(cfg),
		Update:                NewUpdateClient(cfg),
		User:                  NewUserClient(cfg),
		WingetConfigExclusion: NewWingetConfigExclusionClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                   ctx,
		config:                cfg,
		Agent:                 NewAgentClient(cfg),
		Antivirus:             NewAntivirusClient(cfg),
		App:                   NewAppClient(cfg),
		Certificate:           NewCertificateClient(cfg),
		Computer:              NewComputerClient(cfg),
		Deployment:            NewDeploymentClient(cfg),
		LogicalDisk:           NewLogicalDiskClient(cfg),
		Metadata:              NewMetadataClient(cfg),
		Monitor:               NewMonitorClient(cfg),
		NetworkAdapter:        NewNetworkAdapterClient(cfg),
		OperatingSystem:       NewOperatingSystemClient(cfg),
		OrgMetadata:           NewOrgMetadataClient(cfg),
		Printer:               NewPrinterClient(cfg),
		Profile:               NewProfileClient(cfg),
		Release:               NewReleaseClient(cfg),
		Revocation:            NewRevocationClient(cfg),
		Server:                NewServerClient(cfg),
		Sessions:              NewSessionsClient(cfg),
		Settings:              NewSettingsClient(cfg),
		Share:                 NewShareClient(cfg),
		SystemUpdate:          NewSystemUpdateClient(cfg),
		Tag:                   NewTagClient(cfg),
		Task:                  NewTaskClient(cfg),
		Update:                NewUpdateClient(cfg),
		User:                  NewUserClient(cfg),
		WingetConfigExclusion: NewWingetConfigExclusionClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Agent.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Agent, c.Antivirus, c.App, c.Certificate, c.Computer, c.Deployment,
		c.LogicalDisk, c.Metadata, c.Monitor, c.NetworkAdapter, c.OperatingSystem,
		c.OrgMetadata, c.Printer, c.Profile, c.Release, c.Revocation, c.Server,
		c.Sessions, c.Settings, c.Share, c.SystemUpdate, c.Tag, c.Task, c.Update,
		c.User, c.WingetConfigExclusion,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Agent, c.Antivirus, c.App, c.Certificate, c.Computer, c.Deployment,
		c.LogicalDisk, c.Metadata, c.Monitor, c.NetworkAdapter, c.OperatingSystem,
		c.OrgMetadata, c.Printer, c.Profile, c.Release, c.Revocation, c.Server,
		c.Sessions, c.Settings, c.Share, c.SystemUpdate, c.Tag, c.Task, c.Update,
		c.User, c.WingetConfigExclusion,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AgentMutation:
		return c.Agent.mutate(ctx, m)
	case *AntivirusMutation:
		return c.Antivirus.mutate(ctx, m)
	case *AppMutation:
		return c.App.mutate(ctx, m)
	case *CertificateMutation:
		return c.Certificate.mutate(ctx, m)
	case *ComputerMutation:
		return c.Computer.mutate(ctx, m)
	case *DeploymentMutation:
		return c.Deployment.mutate(ctx, m)
	case *LogicalDiskMutation:
		return c.LogicalDisk.mutate(ctx, m)
	case *MetadataMutation:
		return c.Metadata.mutate(ctx, m)
	case *MonitorMutation:
		return c.Monitor.mutate(ctx, m)
	case *NetworkAdapterMutation:
		return c.NetworkAdapter.mutate(ctx, m)
	case *OperatingSystemMutation:
		return c.OperatingSystem.mutate(ctx, m)
	case *OrgMetadataMutation:
		return c.OrgMetadata.mutate(ctx, m)
	case *PrinterMutation:
		return c.Printer.mutate(ctx, m)
	case *ProfileMutation:
		return c.Profile.mutate(ctx, m)
	case *ReleaseMutation:
		return c.Release.mutate(ctx, m)
	case *RevocationMutation:
		return c.Revocation.mutate(ctx, m)
	case *ServerMutation:
		return c.Server.mutate(ctx, m)
	case *SessionsMutation:
		return c.Sessions.mutate(ctx, m)
	case *SettingsMutation:
		return c.Settings.mutate(ctx, m)
	case *ShareMutation:
		return c.Share.mutate(ctx, m)
	case *SystemUpdateMutation:
		return c.SystemUpdate.mutate(ctx, m)
	case *TagMutation:
		return c.Tag.mutate(ctx, m)
	case *TaskMutation:
		return c.Task.mutate(ctx, m)
	case *UpdateMutation:
		return c.Update.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *WingetConfigExclusionMutation:
		return c.WingetConfigExclusion.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AgentClient is a client for the Agent schema.
type AgentClient struct {
	config
}

// NewAgentClient returns a client for the Agent from the given config.
func NewAgentClient(c config) *AgentClient {
	return &AgentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `agent.Hooks(f(g(h())))`.
func (c *AgentClient) Use(hooks ...Hook) {
	c.hooks.Agent = append(c.hooks.Agent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `agent.Intercept(f(g(h())))`.
func (c *AgentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Agent = append(c.inters.Agent, interceptors...)
}

// Create returns a builder for creating a Agent entity.
func (c *AgentClient) Create() *AgentCreate {
	mutation := newAgentMutation(c.config, OpCreate)
	return &AgentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Agent entities.
func (c *AgentClient) CreateBulk(builders ...*AgentCreate) *AgentCreateBulk {
	return &AgentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AgentClient) MapCreateBulk(slice any, setFunc func(*AgentCreate, int)) *AgentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AgentCreateBulk{err: fmt.Errorf("calling to AgentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AgentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AgentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Agent.
func (c *AgentClient) Update() *AgentUpdate {
	mutation := newAgentMutation(c.config, OpUpdate)
	return &AgentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AgentClient) UpdateOne(a *Agent) *AgentUpdateOne {
	mutation := newAgentMutation(c.config, OpUpdateOne, withAgent(a))
	return &AgentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AgentClient) UpdateOneID(id string) *AgentUpdateOne {
	mutation := newAgentMutation(c.config, OpUpdateOne, withAgentID(id))
	return &AgentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Agent.
func (c *AgentClient) Delete() *AgentDelete {
	mutation := newAgentMutation(c.config, OpDelete)
	return &AgentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AgentClient) DeleteOne(a *Agent) *AgentDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AgentClient) DeleteOneID(id string) *AgentDeleteOne {
	builder := c.Delete().Where(agent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AgentDeleteOne{builder}
}

// Query returns a query builder for Agent.
func (c *AgentClient) Query() *AgentQuery {
	return &AgentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAgent},
		inters: c.Interceptors(),
	}
}

// Get returns a Agent entity by its id.
func (c *AgentClient) Get(ctx context.Context, id string) (*Agent, error) {
	return c.Query().Where(agent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AgentClient) GetX(ctx context.Context, id string) *Agent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryComputer queries the computer edge of a Agent.
func (c *AgentClient) QueryComputer(a *Agent) *ComputerQuery {
	query := (&ComputerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agent.Table, agent.FieldID, id),
			sqlgraph.To(computer.Table, computer.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, agent.ComputerTable, agent.ComputerColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOperatingsystem queries the operatingsystem edge of a Agent.
func (c *AgentClient) QueryOperatingsystem(a *Agent) *OperatingSystemQuery {
	query := (&OperatingSystemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agent.Table, agent.FieldID, id),
			sqlgraph.To(operatingsystem.Table, operatingsystem.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, agent.OperatingsystemTable, agent.OperatingsystemColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySystemupdate queries the systemupdate edge of a Agent.
func (c *AgentClient) QuerySystemupdate(a *Agent) *SystemUpdateQuery {
	query := (&SystemUpdateClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agent.Table, agent.FieldID, id),
			sqlgraph.To(systemupdate.Table, systemupdate.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, agent.SystemupdateTable, agent.SystemupdateColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAntivirus queries the antivirus edge of a Agent.
func (c *AgentClient) QueryAntivirus(a *Agent) *AntivirusQuery {
	query := (&AntivirusClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agent.Table, agent.FieldID, id),
			sqlgraph.To(antivirus.Table, antivirus.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, agent.AntivirusTable, agent.AntivirusColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLogicaldisks queries the logicaldisks edge of a Agent.
func (c *AgentClient) QueryLogicaldisks(a *Agent) *LogicalDiskQuery {
	query := (&LogicalDiskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agent.Table, agent.FieldID, id),
			sqlgraph.To(logicaldisk.Table, logicaldisk.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, agent.LogicaldisksTable, agent.LogicaldisksColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryApps queries the apps edge of a Agent.
func (c *AgentClient) QueryApps(a *Agent) *AppQuery {
	query := (&AppClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agent.Table, agent.FieldID, id),
			sqlgraph.To(app.Table, app.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, agent.AppsTable, agent.AppsColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMonitors queries the monitors edge of a Agent.
func (c *AgentClient) QueryMonitors(a *Agent) *MonitorQuery {
	query := (&MonitorClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agent.Table, agent.FieldID, id),
			sqlgraph.To(monitor.Table, monitor.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, agent.MonitorsTable, agent.MonitorsColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryShares queries the shares edge of a Agent.
func (c *AgentClient) QueryShares(a *Agent) *ShareQuery {
	query := (&ShareClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agent.Table, agent.FieldID, id),
			sqlgraph.To(share.Table, share.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, agent.SharesTable, agent.SharesColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrinters queries the printers edge of a Agent.
func (c *AgentClient) QueryPrinters(a *Agent) *PrinterQuery {
	query := (&PrinterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agent.Table, agent.FieldID, id),
			sqlgraph.To(printer.Table, printer.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, agent.PrintersTable, agent.PrintersColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNetworkadapters queries the networkadapters edge of a Agent.
func (c *AgentClient) QueryNetworkadapters(a *Agent) *NetworkAdapterQuery {
	query := (&NetworkAdapterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agent.Table, agent.FieldID, id),
			sqlgraph.To(networkadapter.Table, networkadapter.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, agent.NetworkadaptersTable, agent.NetworkadaptersColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDeployments queries the deployments edge of a Agent.
func (c *AgentClient) QueryDeployments(a *Agent) *DeploymentQuery {
	query := (&DeploymentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agent.Table, agent.FieldID, id),
			sqlgraph.To(deployment.Table, deployment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, agent.DeploymentsTable, agent.DeploymentsColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUpdates queries the updates edge of a Agent.
func (c *AgentClient) QueryUpdates(a *Agent) *UpdateQuery {
	query := (&UpdateClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agent.Table, agent.FieldID, id),
			sqlgraph.To(update.Table, update.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, agent.UpdatesTable, agent.UpdatesColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTags queries the tags edge of a Agent.
func (c *AgentClient) QueryTags(a *Agent) *TagQuery {
	query := (&TagClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agent.Table, agent.FieldID, id),
			sqlgraph.To(tag.Table, tag.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, agent.TagsTable, agent.TagsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMetadata queries the metadata edge of a Agent.
func (c *AgentClient) QueryMetadata(a *Agent) *MetadataQuery {
	query := (&MetadataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agent.Table, agent.FieldID, id),
			sqlgraph.To(metadata.Table, metadata.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, agent.MetadataTable, agent.MetadataColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWingetcfgexclusions queries the wingetcfgexclusions edge of a Agent.
func (c *AgentClient) QueryWingetcfgexclusions(a *Agent) *WingetConfigExclusionQuery {
	query := (&WingetConfigExclusionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agent.Table, agent.FieldID, id),
			sqlgraph.To(wingetconfigexclusion.Table, wingetconfigexclusion.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, agent.WingetcfgexclusionsTable, agent.WingetcfgexclusionsColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRelease queries the release edge of a Agent.
func (c *AgentClient) QueryRelease(a *Agent) *ReleaseQuery {
	query := (&ReleaseClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agent.Table, agent.FieldID, id),
			sqlgraph.To(release.Table, release.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, agent.ReleaseTable, agent.ReleaseColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProfile queries the profile edge of a Agent.
func (c *AgentClient) QueryProfile(a *Agent) *ProfileQuery {
	query := (&ProfileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agent.Table, agent.FieldID, id),
			sqlgraph.To(profile.Table, profile.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, agent.ProfileTable, agent.ProfilePrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AgentClient) Hooks() []Hook {
	return c.hooks.Agent
}

// Interceptors returns the client interceptors.
func (c *AgentClient) Interceptors() []Interceptor {
	return c.inters.Agent
}

func (c *AgentClient) mutate(ctx context.Context, m *AgentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AgentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AgentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AgentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AgentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Agent mutation op: %q", m.Op())
	}
}

// AntivirusClient is a client for the Antivirus schema.
type AntivirusClient struct {
	config
}

// NewAntivirusClient returns a client for the Antivirus from the given config.
func NewAntivirusClient(c config) *AntivirusClient {
	return &AntivirusClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `antivirus.Hooks(f(g(h())))`.
func (c *AntivirusClient) Use(hooks ...Hook) {
	c.hooks.Antivirus = append(c.hooks.Antivirus, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `antivirus.Intercept(f(g(h())))`.
func (c *AntivirusClient) Intercept(interceptors ...Interceptor) {
	c.inters.Antivirus = append(c.inters.Antivirus, interceptors...)
}

// Create returns a builder for creating a Antivirus entity.
func (c *AntivirusClient) Create() *AntivirusCreate {
	mutation := newAntivirusMutation(c.config, OpCreate)
	return &AntivirusCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Antivirus entities.
func (c *AntivirusClient) CreateBulk(builders ...*AntivirusCreate) *AntivirusCreateBulk {
	return &AntivirusCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AntivirusClient) MapCreateBulk(slice any, setFunc func(*AntivirusCreate, int)) *AntivirusCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AntivirusCreateBulk{err: fmt.Errorf("calling to AntivirusClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AntivirusCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AntivirusCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Antivirus.
func (c *AntivirusClient) Update() *AntivirusUpdate {
	mutation := newAntivirusMutation(c.config, OpUpdate)
	return &AntivirusUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AntivirusClient) UpdateOne(a *Antivirus) *AntivirusUpdateOne {
	mutation := newAntivirusMutation(c.config, OpUpdateOne, withAntivirus(a))
	return &AntivirusUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AntivirusClient) UpdateOneID(id int) *AntivirusUpdateOne {
	mutation := newAntivirusMutation(c.config, OpUpdateOne, withAntivirusID(id))
	return &AntivirusUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Antivirus.
func (c *AntivirusClient) Delete() *AntivirusDelete {
	mutation := newAntivirusMutation(c.config, OpDelete)
	return &AntivirusDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AntivirusClient) DeleteOne(a *Antivirus) *AntivirusDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AntivirusClient) DeleteOneID(id int) *AntivirusDeleteOne {
	builder := c.Delete().Where(antivirus.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AntivirusDeleteOne{builder}
}

// Query returns a query builder for Antivirus.
func (c *AntivirusClient) Query() *AntivirusQuery {
	return &AntivirusQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAntivirus},
		inters: c.Interceptors(),
	}
}

// Get returns a Antivirus entity by its id.
func (c *AntivirusClient) Get(ctx context.Context, id int) (*Antivirus, error) {
	return c.Query().Where(antivirus.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AntivirusClient) GetX(ctx context.Context, id int) *Antivirus {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Antivirus.
func (c *AntivirusClient) QueryOwner(a *Antivirus) *AgentQuery {
	query := (&AgentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(antivirus.Table, antivirus.FieldID, id),
			sqlgraph.To(agent.Table, agent.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, antivirus.OwnerTable, antivirus.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AntivirusClient) Hooks() []Hook {
	return c.hooks.Antivirus
}

// Interceptors returns the client interceptors.
func (c *AntivirusClient) Interceptors() []Interceptor {
	return c.inters.Antivirus
}

func (c *AntivirusClient) mutate(ctx context.Context, m *AntivirusMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AntivirusCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AntivirusUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AntivirusUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AntivirusDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Antivirus mutation op: %q", m.Op())
	}
}

// AppClient is a client for the App schema.
type AppClient struct {
	config
}

// NewAppClient returns a client for the App from the given config.
func NewAppClient(c config) *AppClient {
	return &AppClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `app.Hooks(f(g(h())))`.
func (c *AppClient) Use(hooks ...Hook) {
	c.hooks.App = append(c.hooks.App, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `app.Intercept(f(g(h())))`.
func (c *AppClient) Intercept(interceptors ...Interceptor) {
	c.inters.App = append(c.inters.App, interceptors...)
}

// Create returns a builder for creating a App entity.
func (c *AppClient) Create() *AppCreate {
	mutation := newAppMutation(c.config, OpCreate)
	return &AppCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of App entities.
func (c *AppClient) CreateBulk(builders ...*AppCreate) *AppCreateBulk {
	return &AppCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AppClient) MapCreateBulk(slice any, setFunc func(*AppCreate, int)) *AppCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AppCreateBulk{err: fmt.Errorf("calling to AppClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AppCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AppCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for App.
func (c *AppClient) Update() *AppUpdate {
	mutation := newAppMutation(c.config, OpUpdate)
	return &AppUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppClient) UpdateOne(a *App) *AppUpdateOne {
	mutation := newAppMutation(c.config, OpUpdateOne, withApp(a))
	return &AppUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppClient) UpdateOneID(id int) *AppUpdateOne {
	mutation := newAppMutation(c.config, OpUpdateOne, withAppID(id))
	return &AppUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for App.
func (c *AppClient) Delete() *AppDelete {
	mutation := newAppMutation(c.config, OpDelete)
	return &AppDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppClient) DeleteOne(a *App) *AppDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppClient) DeleteOneID(id int) *AppDeleteOne {
	builder := c.Delete().Where(app.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppDeleteOne{builder}
}

// Query returns a query builder for App.
func (c *AppClient) Query() *AppQuery {
	return &AppQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeApp},
		inters: c.Interceptors(),
	}
}

// Get returns a App entity by its id.
func (c *AppClient) Get(ctx context.Context, id int) (*App, error) {
	return c.Query().Where(app.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppClient) GetX(ctx context.Context, id int) *App {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a App.
func (c *AppClient) QueryOwner(a *App) *AgentQuery {
	query := (&AgentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(app.Table, app.FieldID, id),
			sqlgraph.To(agent.Table, agent.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, app.OwnerTable, app.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AppClient) Hooks() []Hook {
	return c.hooks.App
}

// Interceptors returns the client interceptors.
func (c *AppClient) Interceptors() []Interceptor {
	return c.inters.App
}

func (c *AppClient) mutate(ctx context.Context, m *AppMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown App mutation op: %q", m.Op())
	}
}

// CertificateClient is a client for the Certificate schema.
type CertificateClient struct {
	config
}

// NewCertificateClient returns a client for the Certificate from the given config.
func NewCertificateClient(c config) *CertificateClient {
	return &CertificateClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `certificate.Hooks(f(g(h())))`.
func (c *CertificateClient) Use(hooks ...Hook) {
	c.hooks.Certificate = append(c.hooks.Certificate, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `certificate.Intercept(f(g(h())))`.
func (c *CertificateClient) Intercept(interceptors ...Interceptor) {
	c.inters.Certificate = append(c.inters.Certificate, interceptors...)
}

// Create returns a builder for creating a Certificate entity.
func (c *CertificateClient) Create() *CertificateCreate {
	mutation := newCertificateMutation(c.config, OpCreate)
	return &CertificateCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Certificate entities.
func (c *CertificateClient) CreateBulk(builders ...*CertificateCreate) *CertificateCreateBulk {
	return &CertificateCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CertificateClient) MapCreateBulk(slice any, setFunc func(*CertificateCreate, int)) *CertificateCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CertificateCreateBulk{err: fmt.Errorf("calling to CertificateClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CertificateCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CertificateCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Certificate.
func (c *CertificateClient) Update() *CertificateUpdate {
	mutation := newCertificateMutation(c.config, OpUpdate)
	return &CertificateUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CertificateClient) UpdateOne(ce *Certificate) *CertificateUpdateOne {
	mutation := newCertificateMutation(c.config, OpUpdateOne, withCertificate(ce))
	return &CertificateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CertificateClient) UpdateOneID(id int64) *CertificateUpdateOne {
	mutation := newCertificateMutation(c.config, OpUpdateOne, withCertificateID(id))
	return &CertificateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Certificate.
func (c *CertificateClient) Delete() *CertificateDelete {
	mutation := newCertificateMutation(c.config, OpDelete)
	return &CertificateDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CertificateClient) DeleteOne(ce *Certificate) *CertificateDeleteOne {
	return c.DeleteOneID(ce.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CertificateClient) DeleteOneID(id int64) *CertificateDeleteOne {
	builder := c.Delete().Where(certificate.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CertificateDeleteOne{builder}
}

// Query returns a query builder for Certificate.
func (c *CertificateClient) Query() *CertificateQuery {
	return &CertificateQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCertificate},
		inters: c.Interceptors(),
	}
}

// Get returns a Certificate entity by its id.
func (c *CertificateClient) Get(ctx context.Context, id int64) (*Certificate, error) {
	return c.Query().Where(certificate.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CertificateClient) GetX(ctx context.Context, id int64) *Certificate {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *CertificateClient) Hooks() []Hook {
	return c.hooks.Certificate
}

// Interceptors returns the client interceptors.
func (c *CertificateClient) Interceptors() []Interceptor {
	return c.inters.Certificate
}

func (c *CertificateClient) mutate(ctx context.Context, m *CertificateMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CertificateCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CertificateUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CertificateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CertificateDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Certificate mutation op: %q", m.Op())
	}
}

// ComputerClient is a client for the Computer schema.
type ComputerClient struct {
	config
}

// NewComputerClient returns a client for the Computer from the given config.
func NewComputerClient(c config) *ComputerClient {
	return &ComputerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `computer.Hooks(f(g(h())))`.
func (c *ComputerClient) Use(hooks ...Hook) {
	c.hooks.Computer = append(c.hooks.Computer, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `computer.Intercept(f(g(h())))`.
func (c *ComputerClient) Intercept(interceptors ...Interceptor) {
	c.inters.Computer = append(c.inters.Computer, interceptors...)
}

// Create returns a builder for creating a Computer entity.
func (c *ComputerClient) Create() *ComputerCreate {
	mutation := newComputerMutation(c.config, OpCreate)
	return &ComputerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Computer entities.
func (c *ComputerClient) CreateBulk(builders ...*ComputerCreate) *ComputerCreateBulk {
	return &ComputerCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ComputerClient) MapCreateBulk(slice any, setFunc func(*ComputerCreate, int)) *ComputerCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ComputerCreateBulk{err: fmt.Errorf("calling to ComputerClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ComputerCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ComputerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Computer.
func (c *ComputerClient) Update() *ComputerUpdate {
	mutation := newComputerMutation(c.config, OpUpdate)
	return &ComputerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ComputerClient) UpdateOne(co *Computer) *ComputerUpdateOne {
	mutation := newComputerMutation(c.config, OpUpdateOne, withComputer(co))
	return &ComputerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ComputerClient) UpdateOneID(id int) *ComputerUpdateOne {
	mutation := newComputerMutation(c.config, OpUpdateOne, withComputerID(id))
	return &ComputerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Computer.
func (c *ComputerClient) Delete() *ComputerDelete {
	mutation := newComputerMutation(c.config, OpDelete)
	return &ComputerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ComputerClient) DeleteOne(co *Computer) *ComputerDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ComputerClient) DeleteOneID(id int) *ComputerDeleteOne {
	builder := c.Delete().Where(computer.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ComputerDeleteOne{builder}
}

// Query returns a query builder for Computer.
func (c *ComputerClient) Query() *ComputerQuery {
	return &ComputerQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeComputer},
		inters: c.Interceptors(),
	}
}

// Get returns a Computer entity by its id.
func (c *ComputerClient) Get(ctx context.Context, id int) (*Computer, error) {
	return c.Query().Where(computer.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ComputerClient) GetX(ctx context.Context, id int) *Computer {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Computer.
func (c *ComputerClient) QueryOwner(co *Computer) *AgentQuery {
	query := (&AgentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(computer.Table, computer.FieldID, id),
			sqlgraph.To(agent.Table, agent.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, computer.OwnerTable, computer.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ComputerClient) Hooks() []Hook {
	return c.hooks.Computer
}

// Interceptors returns the client interceptors.
func (c *ComputerClient) Interceptors() []Interceptor {
	return c.inters.Computer
}

func (c *ComputerClient) mutate(ctx context.Context, m *ComputerMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ComputerCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ComputerUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ComputerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ComputerDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Computer mutation op: %q", m.Op())
	}
}

// DeploymentClient is a client for the Deployment schema.
type DeploymentClient struct {
	config
}

// NewDeploymentClient returns a client for the Deployment from the given config.
func NewDeploymentClient(c config) *DeploymentClient {
	return &DeploymentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `deployment.Hooks(f(g(h())))`.
func (c *DeploymentClient) Use(hooks ...Hook) {
	c.hooks.Deployment = append(c.hooks.Deployment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `deployment.Intercept(f(g(h())))`.
func (c *DeploymentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Deployment = append(c.inters.Deployment, interceptors...)
}

// Create returns a builder for creating a Deployment entity.
func (c *DeploymentClient) Create() *DeploymentCreate {
	mutation := newDeploymentMutation(c.config, OpCreate)
	return &DeploymentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Deployment entities.
func (c *DeploymentClient) CreateBulk(builders ...*DeploymentCreate) *DeploymentCreateBulk {
	return &DeploymentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DeploymentClient) MapCreateBulk(slice any, setFunc func(*DeploymentCreate, int)) *DeploymentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DeploymentCreateBulk{err: fmt.Errorf("calling to DeploymentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DeploymentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DeploymentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Deployment.
func (c *DeploymentClient) Update() *DeploymentUpdate {
	mutation := newDeploymentMutation(c.config, OpUpdate)
	return &DeploymentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DeploymentClient) UpdateOne(d *Deployment) *DeploymentUpdateOne {
	mutation := newDeploymentMutation(c.config, OpUpdateOne, withDeployment(d))
	return &DeploymentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DeploymentClient) UpdateOneID(id int) *DeploymentUpdateOne {
	mutation := newDeploymentMutation(c.config, OpUpdateOne, withDeploymentID(id))
	return &DeploymentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Deployment.
func (c *DeploymentClient) Delete() *DeploymentDelete {
	mutation := newDeploymentMutation(c.config, OpDelete)
	return &DeploymentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DeploymentClient) DeleteOne(d *Deployment) *DeploymentDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DeploymentClient) DeleteOneID(id int) *DeploymentDeleteOne {
	builder := c.Delete().Where(deployment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DeploymentDeleteOne{builder}
}

// Query returns a query builder for Deployment.
func (c *DeploymentClient) Query() *DeploymentQuery {
	return &DeploymentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDeployment},
		inters: c.Interceptors(),
	}
}

// Get returns a Deployment entity by its id.
func (c *DeploymentClient) Get(ctx context.Context, id int) (*Deployment, error) {
	return c.Query().Where(deployment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DeploymentClient) GetX(ctx context.Context, id int) *Deployment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Deployment.
func (c *DeploymentClient) QueryOwner(d *Deployment) *AgentQuery {
	query := (&AgentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(deployment.Table, deployment.FieldID, id),
			sqlgraph.To(agent.Table, agent.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, deployment.OwnerTable, deployment.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DeploymentClient) Hooks() []Hook {
	return c.hooks.Deployment
}

// Interceptors returns the client interceptors.
func (c *DeploymentClient) Interceptors() []Interceptor {
	return c.inters.Deployment
}

func (c *DeploymentClient) mutate(ctx context.Context, m *DeploymentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DeploymentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DeploymentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DeploymentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DeploymentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Deployment mutation op: %q", m.Op())
	}
}

// LogicalDiskClient is a client for the LogicalDisk schema.
type LogicalDiskClient struct {
	config
}

// NewLogicalDiskClient returns a client for the LogicalDisk from the given config.
func NewLogicalDiskClient(c config) *LogicalDiskClient {
	return &LogicalDiskClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `logicaldisk.Hooks(f(g(h())))`.
func (c *LogicalDiskClient) Use(hooks ...Hook) {
	c.hooks.LogicalDisk = append(c.hooks.LogicalDisk, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `logicaldisk.Intercept(f(g(h())))`.
func (c *LogicalDiskClient) Intercept(interceptors ...Interceptor) {
	c.inters.LogicalDisk = append(c.inters.LogicalDisk, interceptors...)
}

// Create returns a builder for creating a LogicalDisk entity.
func (c *LogicalDiskClient) Create() *LogicalDiskCreate {
	mutation := newLogicalDiskMutation(c.config, OpCreate)
	return &LogicalDiskCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LogicalDisk entities.
func (c *LogicalDiskClient) CreateBulk(builders ...*LogicalDiskCreate) *LogicalDiskCreateBulk {
	return &LogicalDiskCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LogicalDiskClient) MapCreateBulk(slice any, setFunc func(*LogicalDiskCreate, int)) *LogicalDiskCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LogicalDiskCreateBulk{err: fmt.Errorf("calling to LogicalDiskClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LogicalDiskCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LogicalDiskCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LogicalDisk.
func (c *LogicalDiskClient) Update() *LogicalDiskUpdate {
	mutation := newLogicalDiskMutation(c.config, OpUpdate)
	return &LogicalDiskUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LogicalDiskClient) UpdateOne(ld *LogicalDisk) *LogicalDiskUpdateOne {
	mutation := newLogicalDiskMutation(c.config, OpUpdateOne, withLogicalDisk(ld))
	return &LogicalDiskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LogicalDiskClient) UpdateOneID(id int) *LogicalDiskUpdateOne {
	mutation := newLogicalDiskMutation(c.config, OpUpdateOne, withLogicalDiskID(id))
	return &LogicalDiskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LogicalDisk.
func (c *LogicalDiskClient) Delete() *LogicalDiskDelete {
	mutation := newLogicalDiskMutation(c.config, OpDelete)
	return &LogicalDiskDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LogicalDiskClient) DeleteOne(ld *LogicalDisk) *LogicalDiskDeleteOne {
	return c.DeleteOneID(ld.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LogicalDiskClient) DeleteOneID(id int) *LogicalDiskDeleteOne {
	builder := c.Delete().Where(logicaldisk.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LogicalDiskDeleteOne{builder}
}

// Query returns a query builder for LogicalDisk.
func (c *LogicalDiskClient) Query() *LogicalDiskQuery {
	return &LogicalDiskQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLogicalDisk},
		inters: c.Interceptors(),
	}
}

// Get returns a LogicalDisk entity by its id.
func (c *LogicalDiskClient) Get(ctx context.Context, id int) (*LogicalDisk, error) {
	return c.Query().Where(logicaldisk.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LogicalDiskClient) GetX(ctx context.Context, id int) *LogicalDisk {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a LogicalDisk.
func (c *LogicalDiskClient) QueryOwner(ld *LogicalDisk) *AgentQuery {
	query := (&AgentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ld.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(logicaldisk.Table, logicaldisk.FieldID, id),
			sqlgraph.To(agent.Table, agent.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, logicaldisk.OwnerTable, logicaldisk.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(ld.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LogicalDiskClient) Hooks() []Hook {
	return c.hooks.LogicalDisk
}

// Interceptors returns the client interceptors.
func (c *LogicalDiskClient) Interceptors() []Interceptor {
	return c.inters.LogicalDisk
}

func (c *LogicalDiskClient) mutate(ctx context.Context, m *LogicalDiskMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LogicalDiskCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LogicalDiskUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LogicalDiskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LogicalDiskDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown LogicalDisk mutation op: %q", m.Op())
	}
}

// MetadataClient is a client for the Metadata schema.
type MetadataClient struct {
	config
}

// NewMetadataClient returns a client for the Metadata from the given config.
func NewMetadataClient(c config) *MetadataClient {
	return &MetadataClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `metadata.Hooks(f(g(h())))`.
func (c *MetadataClient) Use(hooks ...Hook) {
	c.hooks.Metadata = append(c.hooks.Metadata, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `metadata.Intercept(f(g(h())))`.
func (c *MetadataClient) Intercept(interceptors ...Interceptor) {
	c.inters.Metadata = append(c.inters.Metadata, interceptors...)
}

// Create returns a builder for creating a Metadata entity.
func (c *MetadataClient) Create() *MetadataCreate {
	mutation := newMetadataMutation(c.config, OpCreate)
	return &MetadataCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Metadata entities.
func (c *MetadataClient) CreateBulk(builders ...*MetadataCreate) *MetadataCreateBulk {
	return &MetadataCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MetadataClient) MapCreateBulk(slice any, setFunc func(*MetadataCreate, int)) *MetadataCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MetadataCreateBulk{err: fmt.Errorf("calling to MetadataClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MetadataCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MetadataCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Metadata.
func (c *MetadataClient) Update() *MetadataUpdate {
	mutation := newMetadataMutation(c.config, OpUpdate)
	return &MetadataUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MetadataClient) UpdateOne(m *Metadata) *MetadataUpdateOne {
	mutation := newMetadataMutation(c.config, OpUpdateOne, withMetadata(m))
	return &MetadataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MetadataClient) UpdateOneID(id int) *MetadataUpdateOne {
	mutation := newMetadataMutation(c.config, OpUpdateOne, withMetadataID(id))
	return &MetadataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Metadata.
func (c *MetadataClient) Delete() *MetadataDelete {
	mutation := newMetadataMutation(c.config, OpDelete)
	return &MetadataDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MetadataClient) DeleteOne(m *Metadata) *MetadataDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MetadataClient) DeleteOneID(id int) *MetadataDeleteOne {
	builder := c.Delete().Where(metadata.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MetadataDeleteOne{builder}
}

// Query returns a query builder for Metadata.
func (c *MetadataClient) Query() *MetadataQuery {
	return &MetadataQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMetadata},
		inters: c.Interceptors(),
	}
}

// Get returns a Metadata entity by its id.
func (c *MetadataClient) Get(ctx context.Context, id int) (*Metadata, error) {
	return c.Query().Where(metadata.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MetadataClient) GetX(ctx context.Context, id int) *Metadata {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Metadata.
func (c *MetadataClient) QueryOwner(m *Metadata) *AgentQuery {
	query := (&AgentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(metadata.Table, metadata.FieldID, id),
			sqlgraph.To(agent.Table, agent.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, metadata.OwnerTable, metadata.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrg queries the org edge of a Metadata.
func (c *MetadataClient) QueryOrg(m *Metadata) *OrgMetadataQuery {
	query := (&OrgMetadataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(metadata.Table, metadata.FieldID, id),
			sqlgraph.To(orgmetadata.Table, orgmetadata.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, metadata.OrgTable, metadata.OrgColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MetadataClient) Hooks() []Hook {
	return c.hooks.Metadata
}

// Interceptors returns the client interceptors.
func (c *MetadataClient) Interceptors() []Interceptor {
	return c.inters.Metadata
}

func (c *MetadataClient) mutate(ctx context.Context, m *MetadataMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MetadataCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MetadataUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MetadataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MetadataDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Metadata mutation op: %q", m.Op())
	}
}

// MonitorClient is a client for the Monitor schema.
type MonitorClient struct {
	config
}

// NewMonitorClient returns a client for the Monitor from the given config.
func NewMonitorClient(c config) *MonitorClient {
	return &MonitorClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `monitor.Hooks(f(g(h())))`.
func (c *MonitorClient) Use(hooks ...Hook) {
	c.hooks.Monitor = append(c.hooks.Monitor, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `monitor.Intercept(f(g(h())))`.
func (c *MonitorClient) Intercept(interceptors ...Interceptor) {
	c.inters.Monitor = append(c.inters.Monitor, interceptors...)
}

// Create returns a builder for creating a Monitor entity.
func (c *MonitorClient) Create() *MonitorCreate {
	mutation := newMonitorMutation(c.config, OpCreate)
	return &MonitorCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Monitor entities.
func (c *MonitorClient) CreateBulk(builders ...*MonitorCreate) *MonitorCreateBulk {
	return &MonitorCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MonitorClient) MapCreateBulk(slice any, setFunc func(*MonitorCreate, int)) *MonitorCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MonitorCreateBulk{err: fmt.Errorf("calling to MonitorClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MonitorCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MonitorCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Monitor.
func (c *MonitorClient) Update() *MonitorUpdate {
	mutation := newMonitorMutation(c.config, OpUpdate)
	return &MonitorUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MonitorClient) UpdateOne(m *Monitor) *MonitorUpdateOne {
	mutation := newMonitorMutation(c.config, OpUpdateOne, withMonitor(m))
	return &MonitorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MonitorClient) UpdateOneID(id int) *MonitorUpdateOne {
	mutation := newMonitorMutation(c.config, OpUpdateOne, withMonitorID(id))
	return &MonitorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Monitor.
func (c *MonitorClient) Delete() *MonitorDelete {
	mutation := newMonitorMutation(c.config, OpDelete)
	return &MonitorDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MonitorClient) DeleteOne(m *Monitor) *MonitorDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MonitorClient) DeleteOneID(id int) *MonitorDeleteOne {
	builder := c.Delete().Where(monitor.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MonitorDeleteOne{builder}
}

// Query returns a query builder for Monitor.
func (c *MonitorClient) Query() *MonitorQuery {
	return &MonitorQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMonitor},
		inters: c.Interceptors(),
	}
}

// Get returns a Monitor entity by its id.
func (c *MonitorClient) Get(ctx context.Context, id int) (*Monitor, error) {
	return c.Query().Where(monitor.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MonitorClient) GetX(ctx context.Context, id int) *Monitor {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Monitor.
func (c *MonitorClient) QueryOwner(m *Monitor) *AgentQuery {
	query := (&AgentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(monitor.Table, monitor.FieldID, id),
			sqlgraph.To(agent.Table, agent.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, monitor.OwnerTable, monitor.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MonitorClient) Hooks() []Hook {
	return c.hooks.Monitor
}

// Interceptors returns the client interceptors.
func (c *MonitorClient) Interceptors() []Interceptor {
	return c.inters.Monitor
}

func (c *MonitorClient) mutate(ctx context.Context, m *MonitorMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MonitorCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MonitorUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MonitorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MonitorDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Monitor mutation op: %q", m.Op())
	}
}

// NetworkAdapterClient is a client for the NetworkAdapter schema.
type NetworkAdapterClient struct {
	config
}

// NewNetworkAdapterClient returns a client for the NetworkAdapter from the given config.
func NewNetworkAdapterClient(c config) *NetworkAdapterClient {
	return &NetworkAdapterClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `networkadapter.Hooks(f(g(h())))`.
func (c *NetworkAdapterClient) Use(hooks ...Hook) {
	c.hooks.NetworkAdapter = append(c.hooks.NetworkAdapter, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `networkadapter.Intercept(f(g(h())))`.
func (c *NetworkAdapterClient) Intercept(interceptors ...Interceptor) {
	c.inters.NetworkAdapter = append(c.inters.NetworkAdapter, interceptors...)
}

// Create returns a builder for creating a NetworkAdapter entity.
func (c *NetworkAdapterClient) Create() *NetworkAdapterCreate {
	mutation := newNetworkAdapterMutation(c.config, OpCreate)
	return &NetworkAdapterCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of NetworkAdapter entities.
func (c *NetworkAdapterClient) CreateBulk(builders ...*NetworkAdapterCreate) *NetworkAdapterCreateBulk {
	return &NetworkAdapterCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NetworkAdapterClient) MapCreateBulk(slice any, setFunc func(*NetworkAdapterCreate, int)) *NetworkAdapterCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NetworkAdapterCreateBulk{err: fmt.Errorf("calling to NetworkAdapterClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NetworkAdapterCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NetworkAdapterCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for NetworkAdapter.
func (c *NetworkAdapterClient) Update() *NetworkAdapterUpdate {
	mutation := newNetworkAdapterMutation(c.config, OpUpdate)
	return &NetworkAdapterUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NetworkAdapterClient) UpdateOne(na *NetworkAdapter) *NetworkAdapterUpdateOne {
	mutation := newNetworkAdapterMutation(c.config, OpUpdateOne, withNetworkAdapter(na))
	return &NetworkAdapterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NetworkAdapterClient) UpdateOneID(id int) *NetworkAdapterUpdateOne {
	mutation := newNetworkAdapterMutation(c.config, OpUpdateOne, withNetworkAdapterID(id))
	return &NetworkAdapterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for NetworkAdapter.
func (c *NetworkAdapterClient) Delete() *NetworkAdapterDelete {
	mutation := newNetworkAdapterMutation(c.config, OpDelete)
	return &NetworkAdapterDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NetworkAdapterClient) DeleteOne(na *NetworkAdapter) *NetworkAdapterDeleteOne {
	return c.DeleteOneID(na.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NetworkAdapterClient) DeleteOneID(id int) *NetworkAdapterDeleteOne {
	builder := c.Delete().Where(networkadapter.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NetworkAdapterDeleteOne{builder}
}

// Query returns a query builder for NetworkAdapter.
func (c *NetworkAdapterClient) Query() *NetworkAdapterQuery {
	return &NetworkAdapterQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNetworkAdapter},
		inters: c.Interceptors(),
	}
}

// Get returns a NetworkAdapter entity by its id.
func (c *NetworkAdapterClient) Get(ctx context.Context, id int) (*NetworkAdapter, error) {
	return c.Query().Where(networkadapter.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NetworkAdapterClient) GetX(ctx context.Context, id int) *NetworkAdapter {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a NetworkAdapter.
func (c *NetworkAdapterClient) QueryOwner(na *NetworkAdapter) *AgentQuery {
	query := (&AgentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := na.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(networkadapter.Table, networkadapter.FieldID, id),
			sqlgraph.To(agent.Table, agent.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, networkadapter.OwnerTable, networkadapter.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(na.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NetworkAdapterClient) Hooks() []Hook {
	return c.hooks.NetworkAdapter
}

// Interceptors returns the client interceptors.
func (c *NetworkAdapterClient) Interceptors() []Interceptor {
	return c.inters.NetworkAdapter
}

func (c *NetworkAdapterClient) mutate(ctx context.Context, m *NetworkAdapterMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NetworkAdapterCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NetworkAdapterUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NetworkAdapterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NetworkAdapterDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown NetworkAdapter mutation op: %q", m.Op())
	}
}

// OperatingSystemClient is a client for the OperatingSystem schema.
type OperatingSystemClient struct {
	config
}

// NewOperatingSystemClient returns a client for the OperatingSystem from the given config.
func NewOperatingSystemClient(c config) *OperatingSystemClient {
	return &OperatingSystemClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `operatingsystem.Hooks(f(g(h())))`.
func (c *OperatingSystemClient) Use(hooks ...Hook) {
	c.hooks.OperatingSystem = append(c.hooks.OperatingSystem, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `operatingsystem.Intercept(f(g(h())))`.
func (c *OperatingSystemClient) Intercept(interceptors ...Interceptor) {
	c.inters.OperatingSystem = append(c.inters.OperatingSystem, interceptors...)
}

// Create returns a builder for creating a OperatingSystem entity.
func (c *OperatingSystemClient) Create() *OperatingSystemCreate {
	mutation := newOperatingSystemMutation(c.config, OpCreate)
	return &OperatingSystemCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OperatingSystem entities.
func (c *OperatingSystemClient) CreateBulk(builders ...*OperatingSystemCreate) *OperatingSystemCreateBulk {
	return &OperatingSystemCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OperatingSystemClient) MapCreateBulk(slice any, setFunc func(*OperatingSystemCreate, int)) *OperatingSystemCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OperatingSystemCreateBulk{err: fmt.Errorf("calling to OperatingSystemClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OperatingSystemCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OperatingSystemCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OperatingSystem.
func (c *OperatingSystemClient) Update() *OperatingSystemUpdate {
	mutation := newOperatingSystemMutation(c.config, OpUpdate)
	return &OperatingSystemUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OperatingSystemClient) UpdateOne(os *OperatingSystem) *OperatingSystemUpdateOne {
	mutation := newOperatingSystemMutation(c.config, OpUpdateOne, withOperatingSystem(os))
	return &OperatingSystemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OperatingSystemClient) UpdateOneID(id int) *OperatingSystemUpdateOne {
	mutation := newOperatingSystemMutation(c.config, OpUpdateOne, withOperatingSystemID(id))
	return &OperatingSystemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OperatingSystem.
func (c *OperatingSystemClient) Delete() *OperatingSystemDelete {
	mutation := newOperatingSystemMutation(c.config, OpDelete)
	return &OperatingSystemDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OperatingSystemClient) DeleteOne(os *OperatingSystem) *OperatingSystemDeleteOne {
	return c.DeleteOneID(os.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OperatingSystemClient) DeleteOneID(id int) *OperatingSystemDeleteOne {
	builder := c.Delete().Where(operatingsystem.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OperatingSystemDeleteOne{builder}
}

// Query returns a query builder for OperatingSystem.
func (c *OperatingSystemClient) Query() *OperatingSystemQuery {
	return &OperatingSystemQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOperatingSystem},
		inters: c.Interceptors(),
	}
}

// Get returns a OperatingSystem entity by its id.
func (c *OperatingSystemClient) Get(ctx context.Context, id int) (*OperatingSystem, error) {
	return c.Query().Where(operatingsystem.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OperatingSystemClient) GetX(ctx context.Context, id int) *OperatingSystem {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a OperatingSystem.
func (c *OperatingSystemClient) QueryOwner(os *OperatingSystem) *AgentQuery {
	query := (&AgentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := os.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(operatingsystem.Table, operatingsystem.FieldID, id),
			sqlgraph.To(agent.Table, agent.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, operatingsystem.OwnerTable, operatingsystem.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(os.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OperatingSystemClient) Hooks() []Hook {
	return c.hooks.OperatingSystem
}

// Interceptors returns the client interceptors.
func (c *OperatingSystemClient) Interceptors() []Interceptor {
	return c.inters.OperatingSystem
}

func (c *OperatingSystemClient) mutate(ctx context.Context, m *OperatingSystemMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OperatingSystemCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OperatingSystemUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OperatingSystemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OperatingSystemDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OperatingSystem mutation op: %q", m.Op())
	}
}

// OrgMetadataClient is a client for the OrgMetadata schema.
type OrgMetadataClient struct {
	config
}

// NewOrgMetadataClient returns a client for the OrgMetadata from the given config.
func NewOrgMetadataClient(c config) *OrgMetadataClient {
	return &OrgMetadataClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `orgmetadata.Hooks(f(g(h())))`.
func (c *OrgMetadataClient) Use(hooks ...Hook) {
	c.hooks.OrgMetadata = append(c.hooks.OrgMetadata, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `orgmetadata.Intercept(f(g(h())))`.
func (c *OrgMetadataClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrgMetadata = append(c.inters.OrgMetadata, interceptors...)
}

// Create returns a builder for creating a OrgMetadata entity.
func (c *OrgMetadataClient) Create() *OrgMetadataCreate {
	mutation := newOrgMetadataMutation(c.config, OpCreate)
	return &OrgMetadataCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrgMetadata entities.
func (c *OrgMetadataClient) CreateBulk(builders ...*OrgMetadataCreate) *OrgMetadataCreateBulk {
	return &OrgMetadataCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrgMetadataClient) MapCreateBulk(slice any, setFunc func(*OrgMetadataCreate, int)) *OrgMetadataCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrgMetadataCreateBulk{err: fmt.Errorf("calling to OrgMetadataClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrgMetadataCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrgMetadataCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrgMetadata.
func (c *OrgMetadataClient) Update() *OrgMetadataUpdate {
	mutation := newOrgMetadataMutation(c.config, OpUpdate)
	return &OrgMetadataUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrgMetadataClient) UpdateOne(om *OrgMetadata) *OrgMetadataUpdateOne {
	mutation := newOrgMetadataMutation(c.config, OpUpdateOne, withOrgMetadata(om))
	return &OrgMetadataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrgMetadataClient) UpdateOneID(id int) *OrgMetadataUpdateOne {
	mutation := newOrgMetadataMutation(c.config, OpUpdateOne, withOrgMetadataID(id))
	return &OrgMetadataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrgMetadata.
func (c *OrgMetadataClient) Delete() *OrgMetadataDelete {
	mutation := newOrgMetadataMutation(c.config, OpDelete)
	return &OrgMetadataDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrgMetadataClient) DeleteOne(om *OrgMetadata) *OrgMetadataDeleteOne {
	return c.DeleteOneID(om.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrgMetadataClient) DeleteOneID(id int) *OrgMetadataDeleteOne {
	builder := c.Delete().Where(orgmetadata.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrgMetadataDeleteOne{builder}
}

// Query returns a query builder for OrgMetadata.
func (c *OrgMetadataClient) Query() *OrgMetadataQuery {
	return &OrgMetadataQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrgMetadata},
		inters: c.Interceptors(),
	}
}

// Get returns a OrgMetadata entity by its id.
func (c *OrgMetadataClient) Get(ctx context.Context, id int) (*OrgMetadata, error) {
	return c.Query().Where(orgmetadata.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrgMetadataClient) GetX(ctx context.Context, id int) *OrgMetadata {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMetadata queries the metadata edge of a OrgMetadata.
func (c *OrgMetadataClient) QueryMetadata(om *OrgMetadata) *MetadataQuery {
	query := (&MetadataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := om.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orgmetadata.Table, orgmetadata.FieldID, id),
			sqlgraph.To(metadata.Table, metadata.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, orgmetadata.MetadataTable, orgmetadata.MetadataColumn),
		)
		fromV = sqlgraph.Neighbors(om.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrgMetadataClient) Hooks() []Hook {
	return c.hooks.OrgMetadata
}

// Interceptors returns the client interceptors.
func (c *OrgMetadataClient) Interceptors() []Interceptor {
	return c.inters.OrgMetadata
}

func (c *OrgMetadataClient) mutate(ctx context.Context, m *OrgMetadataMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrgMetadataCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrgMetadataUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrgMetadataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrgMetadataDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OrgMetadata mutation op: %q", m.Op())
	}
}

// PrinterClient is a client for the Printer schema.
type PrinterClient struct {
	config
}

// NewPrinterClient returns a client for the Printer from the given config.
func NewPrinterClient(c config) *PrinterClient {
	return &PrinterClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `printer.Hooks(f(g(h())))`.
func (c *PrinterClient) Use(hooks ...Hook) {
	c.hooks.Printer = append(c.hooks.Printer, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `printer.Intercept(f(g(h())))`.
func (c *PrinterClient) Intercept(interceptors ...Interceptor) {
	c.inters.Printer = append(c.inters.Printer, interceptors...)
}

// Create returns a builder for creating a Printer entity.
func (c *PrinterClient) Create() *PrinterCreate {
	mutation := newPrinterMutation(c.config, OpCreate)
	return &PrinterCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Printer entities.
func (c *PrinterClient) CreateBulk(builders ...*PrinterCreate) *PrinterCreateBulk {
	return &PrinterCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PrinterClient) MapCreateBulk(slice any, setFunc func(*PrinterCreate, int)) *PrinterCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PrinterCreateBulk{err: fmt.Errorf("calling to PrinterClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PrinterCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PrinterCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Printer.
func (c *PrinterClient) Update() *PrinterUpdate {
	mutation := newPrinterMutation(c.config, OpUpdate)
	return &PrinterUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PrinterClient) UpdateOne(pr *Printer) *PrinterUpdateOne {
	mutation := newPrinterMutation(c.config, OpUpdateOne, withPrinter(pr))
	return &PrinterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PrinterClient) UpdateOneID(id int) *PrinterUpdateOne {
	mutation := newPrinterMutation(c.config, OpUpdateOne, withPrinterID(id))
	return &PrinterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Printer.
func (c *PrinterClient) Delete() *PrinterDelete {
	mutation := newPrinterMutation(c.config, OpDelete)
	return &PrinterDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PrinterClient) DeleteOne(pr *Printer) *PrinterDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PrinterClient) DeleteOneID(id int) *PrinterDeleteOne {
	builder := c.Delete().Where(printer.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PrinterDeleteOne{builder}
}

// Query returns a query builder for Printer.
func (c *PrinterClient) Query() *PrinterQuery {
	return &PrinterQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePrinter},
		inters: c.Interceptors(),
	}
}

// Get returns a Printer entity by its id.
func (c *PrinterClient) Get(ctx context.Context, id int) (*Printer, error) {
	return c.Query().Where(printer.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PrinterClient) GetX(ctx context.Context, id int) *Printer {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Printer.
func (c *PrinterClient) QueryOwner(pr *Printer) *AgentQuery {
	query := (&AgentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(printer.Table, printer.FieldID, id),
			sqlgraph.To(agent.Table, agent.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, printer.OwnerTable, printer.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PrinterClient) Hooks() []Hook {
	return c.hooks.Printer
}

// Interceptors returns the client interceptors.
func (c *PrinterClient) Interceptors() []Interceptor {
	return c.inters.Printer
}

func (c *PrinterClient) mutate(ctx context.Context, m *PrinterMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PrinterCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PrinterUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PrinterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PrinterDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Printer mutation op: %q", m.Op())
	}
}

// ProfileClient is a client for the Profile schema.
type ProfileClient struct {
	config
}

// NewProfileClient returns a client for the Profile from the given config.
func NewProfileClient(c config) *ProfileClient {
	return &ProfileClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `profile.Hooks(f(g(h())))`.
func (c *ProfileClient) Use(hooks ...Hook) {
	c.hooks.Profile = append(c.hooks.Profile, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `profile.Intercept(f(g(h())))`.
func (c *ProfileClient) Intercept(interceptors ...Interceptor) {
	c.inters.Profile = append(c.inters.Profile, interceptors...)
}

// Create returns a builder for creating a Profile entity.
func (c *ProfileClient) Create() *ProfileCreate {
	mutation := newProfileMutation(c.config, OpCreate)
	return &ProfileCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Profile entities.
func (c *ProfileClient) CreateBulk(builders ...*ProfileCreate) *ProfileCreateBulk {
	return &ProfileCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProfileClient) MapCreateBulk(slice any, setFunc func(*ProfileCreate, int)) *ProfileCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProfileCreateBulk{err: fmt.Errorf("calling to ProfileClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProfileCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProfileCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Profile.
func (c *ProfileClient) Update() *ProfileUpdate {
	mutation := newProfileMutation(c.config, OpUpdate)
	return &ProfileUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProfileClient) UpdateOne(pr *Profile) *ProfileUpdateOne {
	mutation := newProfileMutation(c.config, OpUpdateOne, withProfile(pr))
	return &ProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProfileClient) UpdateOneID(id int) *ProfileUpdateOne {
	mutation := newProfileMutation(c.config, OpUpdateOne, withProfileID(id))
	return &ProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Profile.
func (c *ProfileClient) Delete() *ProfileDelete {
	mutation := newProfileMutation(c.config, OpDelete)
	return &ProfileDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProfileClient) DeleteOne(pr *Profile) *ProfileDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProfileClient) DeleteOneID(id int) *ProfileDeleteOne {
	builder := c.Delete().Where(profile.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProfileDeleteOne{builder}
}

// Query returns a query builder for Profile.
func (c *ProfileClient) Query() *ProfileQuery {
	return &ProfileQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProfile},
		inters: c.Interceptors(),
	}
}

// Get returns a Profile entity by its id.
func (c *ProfileClient) Get(ctx context.Context, id int) (*Profile, error) {
	return c.Query().Where(profile.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProfileClient) GetX(ctx context.Context, id int) *Profile {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTags queries the tags edge of a Profile.
func (c *ProfileClient) QueryTags(pr *Profile) *TagQuery {
	query := (&TagClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(profile.Table, profile.FieldID, id),
			sqlgraph.To(tag.Table, tag.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, profile.TagsTable, profile.TagsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTasks queries the tasks edge of a Profile.
func (c *ProfileClient) QueryTasks(pr *Profile) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(profile.Table, profile.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, profile.TasksTable, profile.TasksColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAgents queries the agents edge of a Profile.
func (c *ProfileClient) QueryAgents(pr *Profile) *AgentQuery {
	query := (&AgentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(profile.Table, profile.FieldID, id),
			sqlgraph.To(agent.Table, agent.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, profile.AgentsTable, profile.AgentsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProfileClient) Hooks() []Hook {
	return c.hooks.Profile
}

// Interceptors returns the client interceptors.
func (c *ProfileClient) Interceptors() []Interceptor {
	return c.inters.Profile
}

func (c *ProfileClient) mutate(ctx context.Context, m *ProfileMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProfileCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProfileUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProfileDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Profile mutation op: %q", m.Op())
	}
}

// ReleaseClient is a client for the Release schema.
type ReleaseClient struct {
	config
}

// NewReleaseClient returns a client for the Release from the given config.
func NewReleaseClient(c config) *ReleaseClient {
	return &ReleaseClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `release.Hooks(f(g(h())))`.
func (c *ReleaseClient) Use(hooks ...Hook) {
	c.hooks.Release = append(c.hooks.Release, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `release.Intercept(f(g(h())))`.
func (c *ReleaseClient) Intercept(interceptors ...Interceptor) {
	c.inters.Release = append(c.inters.Release, interceptors...)
}

// Create returns a builder for creating a Release entity.
func (c *ReleaseClient) Create() *ReleaseCreate {
	mutation := newReleaseMutation(c.config, OpCreate)
	return &ReleaseCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Release entities.
func (c *ReleaseClient) CreateBulk(builders ...*ReleaseCreate) *ReleaseCreateBulk {
	return &ReleaseCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ReleaseClient) MapCreateBulk(slice any, setFunc func(*ReleaseCreate, int)) *ReleaseCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ReleaseCreateBulk{err: fmt.Errorf("calling to ReleaseClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ReleaseCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ReleaseCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Release.
func (c *ReleaseClient) Update() *ReleaseUpdate {
	mutation := newReleaseMutation(c.config, OpUpdate)
	return &ReleaseUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReleaseClient) UpdateOne(r *Release) *ReleaseUpdateOne {
	mutation := newReleaseMutation(c.config, OpUpdateOne, withRelease(r))
	return &ReleaseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReleaseClient) UpdateOneID(id int) *ReleaseUpdateOne {
	mutation := newReleaseMutation(c.config, OpUpdateOne, withReleaseID(id))
	return &ReleaseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Release.
func (c *ReleaseClient) Delete() *ReleaseDelete {
	mutation := newReleaseMutation(c.config, OpDelete)
	return &ReleaseDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ReleaseClient) DeleteOne(r *Release) *ReleaseDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ReleaseClient) DeleteOneID(id int) *ReleaseDeleteOne {
	builder := c.Delete().Where(release.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReleaseDeleteOne{builder}
}

// Query returns a query builder for Release.
func (c *ReleaseClient) Query() *ReleaseQuery {
	return &ReleaseQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRelease},
		inters: c.Interceptors(),
	}
}

// Get returns a Release entity by its id.
func (c *ReleaseClient) Get(ctx context.Context, id int) (*Release, error) {
	return c.Query().Where(release.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReleaseClient) GetX(ctx context.Context, id int) *Release {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAgents queries the agents edge of a Release.
func (c *ReleaseClient) QueryAgents(r *Release) *AgentQuery {
	query := (&AgentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(release.Table, release.FieldID, id),
			sqlgraph.To(agent.Table, agent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, release.AgentsTable, release.AgentsColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ReleaseClient) Hooks() []Hook {
	return c.hooks.Release
}

// Interceptors returns the client interceptors.
func (c *ReleaseClient) Interceptors() []Interceptor {
	return c.inters.Release
}

func (c *ReleaseClient) mutate(ctx context.Context, m *ReleaseMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ReleaseCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ReleaseUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ReleaseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ReleaseDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Release mutation op: %q", m.Op())
	}
}

// RevocationClient is a client for the Revocation schema.
type RevocationClient struct {
	config
}

// NewRevocationClient returns a client for the Revocation from the given config.
func NewRevocationClient(c config) *RevocationClient {
	return &RevocationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `revocation.Hooks(f(g(h())))`.
func (c *RevocationClient) Use(hooks ...Hook) {
	c.hooks.Revocation = append(c.hooks.Revocation, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `revocation.Intercept(f(g(h())))`.
func (c *RevocationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Revocation = append(c.inters.Revocation, interceptors...)
}

// Create returns a builder for creating a Revocation entity.
func (c *RevocationClient) Create() *RevocationCreate {
	mutation := newRevocationMutation(c.config, OpCreate)
	return &RevocationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Revocation entities.
func (c *RevocationClient) CreateBulk(builders ...*RevocationCreate) *RevocationCreateBulk {
	return &RevocationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RevocationClient) MapCreateBulk(slice any, setFunc func(*RevocationCreate, int)) *RevocationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RevocationCreateBulk{err: fmt.Errorf("calling to RevocationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RevocationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RevocationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Revocation.
func (c *RevocationClient) Update() *RevocationUpdate {
	mutation := newRevocationMutation(c.config, OpUpdate)
	return &RevocationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RevocationClient) UpdateOne(r *Revocation) *RevocationUpdateOne {
	mutation := newRevocationMutation(c.config, OpUpdateOne, withRevocation(r))
	return &RevocationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RevocationClient) UpdateOneID(id int64) *RevocationUpdateOne {
	mutation := newRevocationMutation(c.config, OpUpdateOne, withRevocationID(id))
	return &RevocationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Revocation.
func (c *RevocationClient) Delete() *RevocationDelete {
	mutation := newRevocationMutation(c.config, OpDelete)
	return &RevocationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RevocationClient) DeleteOne(r *Revocation) *RevocationDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RevocationClient) DeleteOneID(id int64) *RevocationDeleteOne {
	builder := c.Delete().Where(revocation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RevocationDeleteOne{builder}
}

// Query returns a query builder for Revocation.
func (c *RevocationClient) Query() *RevocationQuery {
	return &RevocationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRevocation},
		inters: c.Interceptors(),
	}
}

// Get returns a Revocation entity by its id.
func (c *RevocationClient) Get(ctx context.Context, id int64) (*Revocation, error) {
	return c.Query().Where(revocation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RevocationClient) GetX(ctx context.Context, id int64) *Revocation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *RevocationClient) Hooks() []Hook {
	return c.hooks.Revocation
}

// Interceptors returns the client interceptors.
func (c *RevocationClient) Interceptors() []Interceptor {
	return c.inters.Revocation
}

func (c *RevocationClient) mutate(ctx context.Context, m *RevocationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RevocationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RevocationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RevocationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RevocationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Revocation mutation op: %q", m.Op())
	}
}

// ServerClient is a client for the Server schema.
type ServerClient struct {
	config
}

// NewServerClient returns a client for the Server from the given config.
func NewServerClient(c config) *ServerClient {
	return &ServerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `server.Hooks(f(g(h())))`.
func (c *ServerClient) Use(hooks ...Hook) {
	c.hooks.Server = append(c.hooks.Server, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `server.Intercept(f(g(h())))`.
func (c *ServerClient) Intercept(interceptors ...Interceptor) {
	c.inters.Server = append(c.inters.Server, interceptors...)
}

// Create returns a builder for creating a Server entity.
func (c *ServerClient) Create() *ServerCreate {
	mutation := newServerMutation(c.config, OpCreate)
	return &ServerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Server entities.
func (c *ServerClient) CreateBulk(builders ...*ServerCreate) *ServerCreateBulk {
	return &ServerCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ServerClient) MapCreateBulk(slice any, setFunc func(*ServerCreate, int)) *ServerCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ServerCreateBulk{err: fmt.Errorf("calling to ServerClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ServerCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ServerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Server.
func (c *ServerClient) Update() *ServerUpdate {
	mutation := newServerMutation(c.config, OpUpdate)
	return &ServerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ServerClient) UpdateOne(s *Server) *ServerUpdateOne {
	mutation := newServerMutation(c.config, OpUpdateOne, withServer(s))
	return &ServerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ServerClient) UpdateOneID(id int) *ServerUpdateOne {
	mutation := newServerMutation(c.config, OpUpdateOne, withServerID(id))
	return &ServerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Server.
func (c *ServerClient) Delete() *ServerDelete {
	mutation := newServerMutation(c.config, OpDelete)
	return &ServerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ServerClient) DeleteOne(s *Server) *ServerDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ServerClient) DeleteOneID(id int) *ServerDeleteOne {
	builder := c.Delete().Where(server.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ServerDeleteOne{builder}
}

// Query returns a query builder for Server.
func (c *ServerClient) Query() *ServerQuery {
	return &ServerQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeServer},
		inters: c.Interceptors(),
	}
}

// Get returns a Server entity by its id.
func (c *ServerClient) Get(ctx context.Context, id int) (*Server, error) {
	return c.Query().Where(server.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ServerClient) GetX(ctx context.Context, id int) *Server {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ServerClient) Hooks() []Hook {
	return c.hooks.Server
}

// Interceptors returns the client interceptors.
func (c *ServerClient) Interceptors() []Interceptor {
	return c.inters.Server
}

func (c *ServerClient) mutate(ctx context.Context, m *ServerMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ServerCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ServerUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ServerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ServerDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Server mutation op: %q", m.Op())
	}
}

// SessionsClient is a client for the Sessions schema.
type SessionsClient struct {
	config
}

// NewSessionsClient returns a client for the Sessions from the given config.
func NewSessionsClient(c config) *SessionsClient {
	return &SessionsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `sessions.Hooks(f(g(h())))`.
func (c *SessionsClient) Use(hooks ...Hook) {
	c.hooks.Sessions = append(c.hooks.Sessions, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `sessions.Intercept(f(g(h())))`.
func (c *SessionsClient) Intercept(interceptors ...Interceptor) {
	c.inters.Sessions = append(c.inters.Sessions, interceptors...)
}

// Create returns a builder for creating a Sessions entity.
func (c *SessionsClient) Create() *SessionsCreate {
	mutation := newSessionsMutation(c.config, OpCreate)
	return &SessionsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Sessions entities.
func (c *SessionsClient) CreateBulk(builders ...*SessionsCreate) *SessionsCreateBulk {
	return &SessionsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SessionsClient) MapCreateBulk(slice any, setFunc func(*SessionsCreate, int)) *SessionsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SessionsCreateBulk{err: fmt.Errorf("calling to SessionsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SessionsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SessionsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Sessions.
func (c *SessionsClient) Update() *SessionsUpdate {
	mutation := newSessionsMutation(c.config, OpUpdate)
	return &SessionsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SessionsClient) UpdateOne(s *Sessions) *SessionsUpdateOne {
	mutation := newSessionsMutation(c.config, OpUpdateOne, withSessions(s))
	return &SessionsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SessionsClient) UpdateOneID(id string) *SessionsUpdateOne {
	mutation := newSessionsMutation(c.config, OpUpdateOne, withSessionsID(id))
	return &SessionsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Sessions.
func (c *SessionsClient) Delete() *SessionsDelete {
	mutation := newSessionsMutation(c.config, OpDelete)
	return &SessionsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SessionsClient) DeleteOne(s *Sessions) *SessionsDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SessionsClient) DeleteOneID(id string) *SessionsDeleteOne {
	builder := c.Delete().Where(sessions.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SessionsDeleteOne{builder}
}

// Query returns a query builder for Sessions.
func (c *SessionsClient) Query() *SessionsQuery {
	return &SessionsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSessions},
		inters: c.Interceptors(),
	}
}

// Get returns a Sessions entity by its id.
func (c *SessionsClient) Get(ctx context.Context, id string) (*Sessions, error) {
	return c.Query().Where(sessions.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SessionsClient) GetX(ctx context.Context, id string) *Sessions {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Sessions.
func (c *SessionsClient) QueryOwner(s *Sessions) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sessions.Table, sessions.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, sessions.OwnerTable, sessions.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SessionsClient) Hooks() []Hook {
	return c.hooks.Sessions
}

// Interceptors returns the client interceptors.
func (c *SessionsClient) Interceptors() []Interceptor {
	return c.inters.Sessions
}

func (c *SessionsClient) mutate(ctx context.Context, m *SessionsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SessionsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SessionsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SessionsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SessionsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Sessions mutation op: %q", m.Op())
	}
}

// SettingsClient is a client for the Settings schema.
type SettingsClient struct {
	config
}

// NewSettingsClient returns a client for the Settings from the given config.
func NewSettingsClient(c config) *SettingsClient {
	return &SettingsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `settings.Hooks(f(g(h())))`.
func (c *SettingsClient) Use(hooks ...Hook) {
	c.hooks.Settings = append(c.hooks.Settings, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `settings.Intercept(f(g(h())))`.
func (c *SettingsClient) Intercept(interceptors ...Interceptor) {
	c.inters.Settings = append(c.inters.Settings, interceptors...)
}

// Create returns a builder for creating a Settings entity.
func (c *SettingsClient) Create() *SettingsCreate {
	mutation := newSettingsMutation(c.config, OpCreate)
	return &SettingsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Settings entities.
func (c *SettingsClient) CreateBulk(builders ...*SettingsCreate) *SettingsCreateBulk {
	return &SettingsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SettingsClient) MapCreateBulk(slice any, setFunc func(*SettingsCreate, int)) *SettingsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SettingsCreateBulk{err: fmt.Errorf("calling to SettingsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SettingsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SettingsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Settings.
func (c *SettingsClient) Update() *SettingsUpdate {
	mutation := newSettingsMutation(c.config, OpUpdate)
	return &SettingsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SettingsClient) UpdateOne(s *Settings) *SettingsUpdateOne {
	mutation := newSettingsMutation(c.config, OpUpdateOne, withSettings(s))
	return &SettingsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SettingsClient) UpdateOneID(id int) *SettingsUpdateOne {
	mutation := newSettingsMutation(c.config, OpUpdateOne, withSettingsID(id))
	return &SettingsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Settings.
func (c *SettingsClient) Delete() *SettingsDelete {
	mutation := newSettingsMutation(c.config, OpDelete)
	return &SettingsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SettingsClient) DeleteOne(s *Settings) *SettingsDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SettingsClient) DeleteOneID(id int) *SettingsDeleteOne {
	builder := c.Delete().Where(settings.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SettingsDeleteOne{builder}
}

// Query returns a query builder for Settings.
func (c *SettingsClient) Query() *SettingsQuery {
	return &SettingsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSettings},
		inters: c.Interceptors(),
	}
}

// Get returns a Settings entity by its id.
func (c *SettingsClient) Get(ctx context.Context, id int) (*Settings, error) {
	return c.Query().Where(settings.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SettingsClient) GetX(ctx context.Context, id int) *Settings {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTag queries the tag edge of a Settings.
func (c *SettingsClient) QueryTag(s *Settings) *TagQuery {
	query := (&TagClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(settings.Table, settings.FieldID, id),
			sqlgraph.To(tag.Table, tag.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, settings.TagTable, settings.TagColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SettingsClient) Hooks() []Hook {
	return c.hooks.Settings
}

// Interceptors returns the client interceptors.
func (c *SettingsClient) Interceptors() []Interceptor {
	return c.inters.Settings
}

func (c *SettingsClient) mutate(ctx context.Context, m *SettingsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SettingsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SettingsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SettingsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SettingsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Settings mutation op: %q", m.Op())
	}
}

// ShareClient is a client for the Share schema.
type ShareClient struct {
	config
}

// NewShareClient returns a client for the Share from the given config.
func NewShareClient(c config) *ShareClient {
	return &ShareClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `share.Hooks(f(g(h())))`.
func (c *ShareClient) Use(hooks ...Hook) {
	c.hooks.Share = append(c.hooks.Share, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `share.Intercept(f(g(h())))`.
func (c *ShareClient) Intercept(interceptors ...Interceptor) {
	c.inters.Share = append(c.inters.Share, interceptors...)
}

// Create returns a builder for creating a Share entity.
func (c *ShareClient) Create() *ShareCreate {
	mutation := newShareMutation(c.config, OpCreate)
	return &ShareCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Share entities.
func (c *ShareClient) CreateBulk(builders ...*ShareCreate) *ShareCreateBulk {
	return &ShareCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ShareClient) MapCreateBulk(slice any, setFunc func(*ShareCreate, int)) *ShareCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ShareCreateBulk{err: fmt.Errorf("calling to ShareClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ShareCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ShareCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Share.
func (c *ShareClient) Update() *ShareUpdate {
	mutation := newShareMutation(c.config, OpUpdate)
	return &ShareUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ShareClient) UpdateOne(s *Share) *ShareUpdateOne {
	mutation := newShareMutation(c.config, OpUpdateOne, withShare(s))
	return &ShareUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ShareClient) UpdateOneID(id int) *ShareUpdateOne {
	mutation := newShareMutation(c.config, OpUpdateOne, withShareID(id))
	return &ShareUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Share.
func (c *ShareClient) Delete() *ShareDelete {
	mutation := newShareMutation(c.config, OpDelete)
	return &ShareDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ShareClient) DeleteOne(s *Share) *ShareDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ShareClient) DeleteOneID(id int) *ShareDeleteOne {
	builder := c.Delete().Where(share.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ShareDeleteOne{builder}
}

// Query returns a query builder for Share.
func (c *ShareClient) Query() *ShareQuery {
	return &ShareQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeShare},
		inters: c.Interceptors(),
	}
}

// Get returns a Share entity by its id.
func (c *ShareClient) Get(ctx context.Context, id int) (*Share, error) {
	return c.Query().Where(share.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ShareClient) GetX(ctx context.Context, id int) *Share {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Share.
func (c *ShareClient) QueryOwner(s *Share) *AgentQuery {
	query := (&AgentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(share.Table, share.FieldID, id),
			sqlgraph.To(agent.Table, agent.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, share.OwnerTable, share.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ShareClient) Hooks() []Hook {
	return c.hooks.Share
}

// Interceptors returns the client interceptors.
func (c *ShareClient) Interceptors() []Interceptor {
	return c.inters.Share
}

func (c *ShareClient) mutate(ctx context.Context, m *ShareMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ShareCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ShareUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ShareUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ShareDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Share mutation op: %q", m.Op())
	}
}

// SystemUpdateClient is a client for the SystemUpdate schema.
type SystemUpdateClient struct {
	config
}

// NewSystemUpdateClient returns a client for the SystemUpdate from the given config.
func NewSystemUpdateClient(c config) *SystemUpdateClient {
	return &SystemUpdateClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `systemupdate.Hooks(f(g(h())))`.
func (c *SystemUpdateClient) Use(hooks ...Hook) {
	c.hooks.SystemUpdate = append(c.hooks.SystemUpdate, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `systemupdate.Intercept(f(g(h())))`.
func (c *SystemUpdateClient) Intercept(interceptors ...Interceptor) {
	c.inters.SystemUpdate = append(c.inters.SystemUpdate, interceptors...)
}

// Create returns a builder for creating a SystemUpdate entity.
func (c *SystemUpdateClient) Create() *SystemUpdateCreate {
	mutation := newSystemUpdateMutation(c.config, OpCreate)
	return &SystemUpdateCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SystemUpdate entities.
func (c *SystemUpdateClient) CreateBulk(builders ...*SystemUpdateCreate) *SystemUpdateCreateBulk {
	return &SystemUpdateCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SystemUpdateClient) MapCreateBulk(slice any, setFunc func(*SystemUpdateCreate, int)) *SystemUpdateCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SystemUpdateCreateBulk{err: fmt.Errorf("calling to SystemUpdateClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SystemUpdateCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SystemUpdateCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SystemUpdate.
func (c *SystemUpdateClient) Update() *SystemUpdateUpdate {
	mutation := newSystemUpdateMutation(c.config, OpUpdate)
	return &SystemUpdateUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SystemUpdateClient) UpdateOne(su *SystemUpdate) *SystemUpdateUpdateOne {
	mutation := newSystemUpdateMutation(c.config, OpUpdateOne, withSystemUpdate(su))
	return &SystemUpdateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SystemUpdateClient) UpdateOneID(id int) *SystemUpdateUpdateOne {
	mutation := newSystemUpdateMutation(c.config, OpUpdateOne, withSystemUpdateID(id))
	return &SystemUpdateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SystemUpdate.
func (c *SystemUpdateClient) Delete() *SystemUpdateDelete {
	mutation := newSystemUpdateMutation(c.config, OpDelete)
	return &SystemUpdateDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SystemUpdateClient) DeleteOne(su *SystemUpdate) *SystemUpdateDeleteOne {
	return c.DeleteOneID(su.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SystemUpdateClient) DeleteOneID(id int) *SystemUpdateDeleteOne {
	builder := c.Delete().Where(systemupdate.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SystemUpdateDeleteOne{builder}
}

// Query returns a query builder for SystemUpdate.
func (c *SystemUpdateClient) Query() *SystemUpdateQuery {
	return &SystemUpdateQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSystemUpdate},
		inters: c.Interceptors(),
	}
}

// Get returns a SystemUpdate entity by its id.
func (c *SystemUpdateClient) Get(ctx context.Context, id int) (*SystemUpdate, error) {
	return c.Query().Where(systemupdate.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SystemUpdateClient) GetX(ctx context.Context, id int) *SystemUpdate {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a SystemUpdate.
func (c *SystemUpdateClient) QueryOwner(su *SystemUpdate) *AgentQuery {
	query := (&AgentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := su.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(systemupdate.Table, systemupdate.FieldID, id),
			sqlgraph.To(agent.Table, agent.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, systemupdate.OwnerTable, systemupdate.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(su.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SystemUpdateClient) Hooks() []Hook {
	return c.hooks.SystemUpdate
}

// Interceptors returns the client interceptors.
func (c *SystemUpdateClient) Interceptors() []Interceptor {
	return c.inters.SystemUpdate
}

func (c *SystemUpdateClient) mutate(ctx context.Context, m *SystemUpdateMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SystemUpdateCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SystemUpdateUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SystemUpdateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SystemUpdateDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SystemUpdate mutation op: %q", m.Op())
	}
}

// TagClient is a client for the Tag schema.
type TagClient struct {
	config
}

// NewTagClient returns a client for the Tag from the given config.
func NewTagClient(c config) *TagClient {
	return &TagClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tag.Hooks(f(g(h())))`.
func (c *TagClient) Use(hooks ...Hook) {
	c.hooks.Tag = append(c.hooks.Tag, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tag.Intercept(f(g(h())))`.
func (c *TagClient) Intercept(interceptors ...Interceptor) {
	c.inters.Tag = append(c.inters.Tag, interceptors...)
}

// Create returns a builder for creating a Tag entity.
func (c *TagClient) Create() *TagCreate {
	mutation := newTagMutation(c.config, OpCreate)
	return &TagCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Tag entities.
func (c *TagClient) CreateBulk(builders ...*TagCreate) *TagCreateBulk {
	return &TagCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TagClient) MapCreateBulk(slice any, setFunc func(*TagCreate, int)) *TagCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TagCreateBulk{err: fmt.Errorf("calling to TagClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TagCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TagCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Tag.
func (c *TagClient) Update() *TagUpdate {
	mutation := newTagMutation(c.config, OpUpdate)
	return &TagUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TagClient) UpdateOne(t *Tag) *TagUpdateOne {
	mutation := newTagMutation(c.config, OpUpdateOne, withTag(t))
	return &TagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TagClient) UpdateOneID(id int) *TagUpdateOne {
	mutation := newTagMutation(c.config, OpUpdateOne, withTagID(id))
	return &TagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Tag.
func (c *TagClient) Delete() *TagDelete {
	mutation := newTagMutation(c.config, OpDelete)
	return &TagDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TagClient) DeleteOne(t *Tag) *TagDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TagClient) DeleteOneID(id int) *TagDeleteOne {
	builder := c.Delete().Where(tag.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TagDeleteOne{builder}
}

// Query returns a query builder for Tag.
func (c *TagClient) Query() *TagQuery {
	return &TagQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTag},
		inters: c.Interceptors(),
	}
}

// Get returns a Tag entity by its id.
func (c *TagClient) Get(ctx context.Context, id int) (*Tag, error) {
	return c.Query().Where(tag.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TagClient) GetX(ctx context.Context, id int) *Tag {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Tag.
func (c *TagClient) QueryOwner(t *Tag) *AgentQuery {
	query := (&AgentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tag.Table, tag.FieldID, id),
			sqlgraph.To(agent.Table, agent.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, tag.OwnerTable, tag.OwnerPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParent queries the parent edge of a Tag.
func (c *TagClient) QueryParent(t *Tag) *TagQuery {
	query := (&TagClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tag.Table, tag.FieldID, id),
			sqlgraph.To(tag.Table, tag.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, tag.ParentTable, tag.ParentColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChildren queries the children edge of a Tag.
func (c *TagClient) QueryChildren(t *Tag) *TagQuery {
	query := (&TagClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tag.Table, tag.FieldID, id),
			sqlgraph.To(tag.Table, tag.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tag.ChildrenTable, tag.ChildrenColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProfile queries the profile edge of a Tag.
func (c *TagClient) QueryProfile(t *Tag) *ProfileQuery {
	query := (&ProfileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tag.Table, tag.FieldID, id),
			sqlgraph.To(profile.Table, profile.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, tag.ProfileTable, tag.ProfilePrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TagClient) Hooks() []Hook {
	return c.hooks.Tag
}

// Interceptors returns the client interceptors.
func (c *TagClient) Interceptors() []Interceptor {
	return c.inters.Tag
}

func (c *TagClient) mutate(ctx context.Context, m *TagMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TagCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TagUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TagDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Tag mutation op: %q", m.Op())
	}
}

// TaskClient is a client for the Task schema.
type TaskClient struct {
	config
}

// NewTaskClient returns a client for the Task from the given config.
func NewTaskClient(c config) *TaskClient {
	return &TaskClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `task.Hooks(f(g(h())))`.
func (c *TaskClient) Use(hooks ...Hook) {
	c.hooks.Task = append(c.hooks.Task, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `task.Intercept(f(g(h())))`.
func (c *TaskClient) Intercept(interceptors ...Interceptor) {
	c.inters.Task = append(c.inters.Task, interceptors...)
}

// Create returns a builder for creating a Task entity.
func (c *TaskClient) Create() *TaskCreate {
	mutation := newTaskMutation(c.config, OpCreate)
	return &TaskCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Task entities.
func (c *TaskClient) CreateBulk(builders ...*TaskCreate) *TaskCreateBulk {
	return &TaskCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TaskClient) MapCreateBulk(slice any, setFunc func(*TaskCreate, int)) *TaskCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TaskCreateBulk{err: fmt.Errorf("calling to TaskClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TaskCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TaskCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Task.
func (c *TaskClient) Update() *TaskUpdate {
	mutation := newTaskMutation(c.config, OpUpdate)
	return &TaskUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TaskClient) UpdateOne(t *Task) *TaskUpdateOne {
	mutation := newTaskMutation(c.config, OpUpdateOne, withTask(t))
	return &TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TaskClient) UpdateOneID(id int) *TaskUpdateOne {
	mutation := newTaskMutation(c.config, OpUpdateOne, withTaskID(id))
	return &TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Task.
func (c *TaskClient) Delete() *TaskDelete {
	mutation := newTaskMutation(c.config, OpDelete)
	return &TaskDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TaskClient) DeleteOne(t *Task) *TaskDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TaskClient) DeleteOneID(id int) *TaskDeleteOne {
	builder := c.Delete().Where(task.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TaskDeleteOne{builder}
}

// Query returns a query builder for Task.
func (c *TaskClient) Query() *TaskQuery {
	return &TaskQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTask},
		inters: c.Interceptors(),
	}
}

// Get returns a Task entity by its id.
func (c *TaskClient) Get(ctx context.Context, id int) (*Task, error) {
	return c.Query().Where(task.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TaskClient) GetX(ctx context.Context, id int) *Task {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTags queries the tags edge of a Task.
func (c *TaskClient) QueryTags(t *Task) *TagQuery {
	query := (&TagClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(tag.Table, tag.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, task.TagsTable, task.TagsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProfile queries the profile edge of a Task.
func (c *TaskClient) QueryProfile(t *Task) *ProfileQuery {
	query := (&ProfileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(profile.Table, profile.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, task.ProfileTable, task.ProfileColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TaskClient) Hooks() []Hook {
	return c.hooks.Task
}

// Interceptors returns the client interceptors.
func (c *TaskClient) Interceptors() []Interceptor {
	return c.inters.Task
}

func (c *TaskClient) mutate(ctx context.Context, m *TaskMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TaskCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TaskUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TaskDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Task mutation op: %q", m.Op())
	}
}

// UpdateClient is a client for the Update schema.
type UpdateClient struct {
	config
}

// NewUpdateClient returns a client for the Update from the given config.
func NewUpdateClient(c config) *UpdateClient {
	return &UpdateClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `update.Hooks(f(g(h())))`.
func (c *UpdateClient) Use(hooks ...Hook) {
	c.hooks.Update = append(c.hooks.Update, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `update.Intercept(f(g(h())))`.
func (c *UpdateClient) Intercept(interceptors ...Interceptor) {
	c.inters.Update = append(c.inters.Update, interceptors...)
}

// Create returns a builder for creating a Update entity.
func (c *UpdateClient) Create() *UpdateCreate {
	mutation := newUpdateMutation(c.config, OpCreate)
	return &UpdateCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Update entities.
func (c *UpdateClient) CreateBulk(builders ...*UpdateCreate) *UpdateCreateBulk {
	return &UpdateCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UpdateClient) MapCreateBulk(slice any, setFunc func(*UpdateCreate, int)) *UpdateCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UpdateCreateBulk{err: fmt.Errorf("calling to UpdateClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UpdateCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UpdateCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Update.
func (c *UpdateClient) Update() *UpdateUpdate {
	mutation := newUpdateMutation(c.config, OpUpdate)
	return &UpdateUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UpdateClient) UpdateOne(u *Update) *UpdateUpdateOne {
	mutation := newUpdateMutation(c.config, OpUpdateOne, withUpdate(u))
	return &UpdateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UpdateClient) UpdateOneID(id int) *UpdateUpdateOne {
	mutation := newUpdateMutation(c.config, OpUpdateOne, withUpdateID(id))
	return &UpdateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Update.
func (c *UpdateClient) Delete() *UpdateDelete {
	mutation := newUpdateMutation(c.config, OpDelete)
	return &UpdateDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UpdateClient) DeleteOne(u *Update) *UpdateDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UpdateClient) DeleteOneID(id int) *UpdateDeleteOne {
	builder := c.Delete().Where(update.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UpdateDeleteOne{builder}
}

// Query returns a query builder for Update.
func (c *UpdateClient) Query() *UpdateQuery {
	return &UpdateQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUpdate},
		inters: c.Interceptors(),
	}
}

// Get returns a Update entity by its id.
func (c *UpdateClient) Get(ctx context.Context, id int) (*Update, error) {
	return c.Query().Where(update.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UpdateClient) GetX(ctx context.Context, id int) *Update {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Update.
func (c *UpdateClient) QueryOwner(u *Update) *AgentQuery {
	query := (&AgentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(update.Table, update.FieldID, id),
			sqlgraph.To(agent.Table, agent.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, update.OwnerTable, update.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UpdateClient) Hooks() []Hook {
	return c.hooks.Update
}

// Interceptors returns the client interceptors.
func (c *UpdateClient) Interceptors() []Interceptor {
	return c.inters.Update
}

func (c *UpdateClient) mutate(ctx context.Context, m *UpdateMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UpdateCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UpdateUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UpdateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UpdateDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Update mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id string) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id string) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id string) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id string) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySessions queries the sessions edge of a User.
func (c *UserClient) QuerySessions(u *User) *SessionsQuery {
	query := (&SessionsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(sessions.Table, sessions.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.SessionsTable, user.SessionsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// WingetConfigExclusionClient is a client for the WingetConfigExclusion schema.
type WingetConfigExclusionClient struct {
	config
}

// NewWingetConfigExclusionClient returns a client for the WingetConfigExclusion from the given config.
func NewWingetConfigExclusionClient(c config) *WingetConfigExclusionClient {
	return &WingetConfigExclusionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `wingetconfigexclusion.Hooks(f(g(h())))`.
func (c *WingetConfigExclusionClient) Use(hooks ...Hook) {
	c.hooks.WingetConfigExclusion = append(c.hooks.WingetConfigExclusion, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `wingetconfigexclusion.Intercept(f(g(h())))`.
func (c *WingetConfigExclusionClient) Intercept(interceptors ...Interceptor) {
	c.inters.WingetConfigExclusion = append(c.inters.WingetConfigExclusion, interceptors...)
}

// Create returns a builder for creating a WingetConfigExclusion entity.
func (c *WingetConfigExclusionClient) Create() *WingetConfigExclusionCreate {
	mutation := newWingetConfigExclusionMutation(c.config, OpCreate)
	return &WingetConfigExclusionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WingetConfigExclusion entities.
func (c *WingetConfigExclusionClient) CreateBulk(builders ...*WingetConfigExclusionCreate) *WingetConfigExclusionCreateBulk {
	return &WingetConfigExclusionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WingetConfigExclusionClient) MapCreateBulk(slice any, setFunc func(*WingetConfigExclusionCreate, int)) *WingetConfigExclusionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WingetConfigExclusionCreateBulk{err: fmt.Errorf("calling to WingetConfigExclusionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WingetConfigExclusionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WingetConfigExclusionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WingetConfigExclusion.
func (c *WingetConfigExclusionClient) Update() *WingetConfigExclusionUpdate {
	mutation := newWingetConfigExclusionMutation(c.config, OpUpdate)
	return &WingetConfigExclusionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WingetConfigExclusionClient) UpdateOne(wce *WingetConfigExclusion) *WingetConfigExclusionUpdateOne {
	mutation := newWingetConfigExclusionMutation(c.config, OpUpdateOne, withWingetConfigExclusion(wce))
	return &WingetConfigExclusionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WingetConfigExclusionClient) UpdateOneID(id int) *WingetConfigExclusionUpdateOne {
	mutation := newWingetConfigExclusionMutation(c.config, OpUpdateOne, withWingetConfigExclusionID(id))
	return &WingetConfigExclusionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WingetConfigExclusion.
func (c *WingetConfigExclusionClient) Delete() *WingetConfigExclusionDelete {
	mutation := newWingetConfigExclusionMutation(c.config, OpDelete)
	return &WingetConfigExclusionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WingetConfigExclusionClient) DeleteOne(wce *WingetConfigExclusion) *WingetConfigExclusionDeleteOne {
	return c.DeleteOneID(wce.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WingetConfigExclusionClient) DeleteOneID(id int) *WingetConfigExclusionDeleteOne {
	builder := c.Delete().Where(wingetconfigexclusion.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WingetConfigExclusionDeleteOne{builder}
}

// Query returns a query builder for WingetConfigExclusion.
func (c *WingetConfigExclusionClient) Query() *WingetConfigExclusionQuery {
	return &WingetConfigExclusionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWingetConfigExclusion},
		inters: c.Interceptors(),
	}
}

// Get returns a WingetConfigExclusion entity by its id.
func (c *WingetConfigExclusionClient) Get(ctx context.Context, id int) (*WingetConfigExclusion, error) {
	return c.Query().Where(wingetconfigexclusion.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WingetConfigExclusionClient) GetX(ctx context.Context, id int) *WingetConfigExclusion {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a WingetConfigExclusion.
func (c *WingetConfigExclusionClient) QueryOwner(wce *WingetConfigExclusion) *AgentQuery {
	query := (&AgentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := wce.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(wingetconfigexclusion.Table, wingetconfigexclusion.FieldID, id),
			sqlgraph.To(agent.Table, agent.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, wingetconfigexclusion.OwnerTable, wingetconfigexclusion.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(wce.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WingetConfigExclusionClient) Hooks() []Hook {
	return c.hooks.WingetConfigExclusion
}

// Interceptors returns the client interceptors.
func (c *WingetConfigExclusionClient) Interceptors() []Interceptor {
	return c.inters.WingetConfigExclusion
}

func (c *WingetConfigExclusionClient) mutate(ctx context.Context, m *WingetConfigExclusionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WingetConfigExclusionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WingetConfigExclusionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WingetConfigExclusionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WingetConfigExclusionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown WingetConfigExclusion mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Agent, Antivirus, App, Certificate, Computer, Deployment, LogicalDisk, Metadata,
		Monitor, NetworkAdapter, OperatingSystem, OrgMetadata, Printer, Profile,
		Release, Revocation, Server, Sessions, Settings, Share, SystemUpdate, Tag,
		Task, Update, User, WingetConfigExclusion []ent.Hook
	}
	inters struct {
		Agent, Antivirus, App, Certificate, Computer, Deployment, LogicalDisk, Metadata,
		Monitor, NetworkAdapter, OperatingSystem, OrgMetadata, Printer, Profile,
		Release, Revocation, Server, Sessions, Settings, Share, SystemUpdate, Tag,
		Task, Update, User, WingetConfigExclusion []ent.Interceptor
	}
)
